import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { usePopper } from 'react-popper';
import { useUniqueId } from '../../hooks';
import { excludeMarginProps } from '../../mixins';
import { Box } from '../Box'; // Margin can't be used with popper elements

export var Popover = function Popover(_ref) {
  var anchorElement = _ref.anchorElement,
      children = _ref.children,
      isOpen = _ref.isOpen,
      _ref$role = _ref.role,
      role = _ref$role === void 0 ? 'dialog' : _ref$role,
      props = _objectWithoutProperties(_ref, ["anchorElement", "children", "isOpen", "role"]);

  var uniquePopoverId = useUniqueId('popover');
  var rest = excludeMarginProps(props);
  useEffect(function () {
    if (!anchorElement) {
      return;
    }

    anchorElement.setAttribute('aria-controls', uniquePopoverId);
    anchorElement.setAttribute('aria-expanded', String(isOpen));
    anchorElement.setAttribute('aria-haspopup', role);
  }, [anchorElement, isOpen, role, uniquePopoverId]);
  return isOpen ? /*#__PURE__*/React.createElement(InternalPopover, _extends({
    anchorElement: anchorElement
  }, rest, {
    id: uniquePopoverId
  }), children) : null;
};

// We use an Internal component that mounts/unmounts on isOpen
// This facilitates running cleanups on some effects.
var InternalPopover = function InternalPopover(_ref2) {
  var anchorElement = _ref2.anchorElement,
      children = _ref2.children,
      _ref2$closeOnClickOut = _ref2.closeOnClickOutside,
      closeOnClickOutside = _ref2$closeOnClickOut === void 0 ? true : _ref2$closeOnClickOut,
      _ref2$closeOnEscKey = _ref2.closeOnEscKey,
      closeOnEscKey = _ref2$closeOnEscKey === void 0 ? true : _ref2$closeOnEscKey,
      id = _ref2.id,
      label = _ref2.label,
      _ref2$matchAnchorElem = _ref2.matchAnchorElementWidth,
      matchAnchorElementWidth = _ref2$matchAnchorElem === void 0 ? false : _ref2$matchAnchorElem,
      _ref2$skidding = _ref2.skidding,
      skidding = _ref2$skidding === void 0 ? 0 : _ref2$skidding,
      _ref2$distance = _ref2.distance,
      distance = _ref2$distance === void 0 ? 4 : _ref2$distance,
      _ref2$onClose = _ref2.onClose,
      onClose = _ref2$onClose === void 0 ? function () {
    return null;
  } : _ref2$onClose,
      _ref2$placement = _ref2.placement,
      placement = _ref2$placement === void 0 ? 'auto' : _ref2$placement,
      role = _ref2.role,
      props = _objectWithoutProperties(_ref2, ["anchorElement", "children", "closeOnClickOutside", "closeOnEscKey", "id", "label", "matchAnchorElementWidth", "skidding", "distance", "onClose", "placement", "role"]);

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      popperElement = _useState2[0],
      setPopperElement = _useState2[1];

  var previousFocus = useRef(typeof document !== 'undefined' ? document.activeElement : null);
  var popperModifiers = useMemo(function () {
    return [{
      name: 'offset',
      options: {
        offset: [skidding, distance]
      }
    }, {
      name: 'sameWidth',
      enabled: matchAnchorElementWidth,
      phase: 'beforeWrite',
      requires: ['computeStyles'],
      fn: function fn(_ref3) {
        var state = _ref3.state;
        state.styles.popper.width = "".concat(state.rects.reference.width, "px");
      },
      effect: function effect(_ref4) {
        var state = _ref4.state;
        var element = state.elements.reference;

        if (element instanceof HTMLElement) {
          state.elements.popper.style.width = "".concat(element.offsetWidth, "px");
        }
      }
    }];
  }, [skidding, distance, matchAnchorElementWidth]);

  var _usePopper = usePopper(anchorElement, popperElement, {
    modifiers: popperModifiers,
    placement: placement
  }),
      styles = _usePopper.styles,
      attributes = _usePopper.attributes;

  useEffect(function () {
    var prevFocus = previousFocus.current;
    return function () {
      if (prevFocus && typeof prevFocus.focus === 'function') {
        prevFocus.focus();
      }
    };
  }, []); // Setup close on click outside

  useEffect(function () {
    if (typeof document === 'undefined' || !closeOnClickOutside) {
      return;
    }

    var clickHandler = function clickHandler(event) {
      if (!(event.target instanceof Element)) {
        return;
      }

      if (popperElement === null || popperElement === void 0 ? void 0 : popperElement.contains(event.target)) {
        return;
      }

      onClose();
    };

    document.addEventListener('click', clickHandler);
    return function () {
      document.removeEventListener('click', clickHandler);
    };
  }, [closeOnClickOutside, onClose, popperElement]); // Setup close on Esc key

  useEffect(function () {
    if (typeof document === 'undefined' || !closeOnEscKey) {
      return;
    }

    var keydownHandler = function keydownHandler(event) {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    document.addEventListener('keydown', keydownHandler);
    return function () {
      document.removeEventListener('keydown', keydownHandler);
    };
  }, [closeOnEscKey, onClose]);
  return /*#__PURE__*/React.createElement(Box, _extends({
    "aria-label": label,
    backgroundColor: "white",
    padding: "medium",
    role: role,
    shadow: "floating",
    tabIndex: -1,
    zIndex: "popover"
  }, props, attributes.popper, {
    id: id,
    ref: setPopperElement,
    style: styles.popper
  }), children);
};