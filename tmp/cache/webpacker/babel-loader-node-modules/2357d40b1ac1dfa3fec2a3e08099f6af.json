{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { depthFirstSearch } from '../../utils';\nexport var initialize = function initialize(nodes, selectable) {\n  var state = recursiveInitialize(nodes, {\n    nodeMap: new Map(),\n    expandedNodeIds: new Set(),\n    flattenedNodeIds: [],\n    focusedNode: null,\n    selectedValues: [],\n    visibleNodeIds: []\n  }, selectable);\n  var selectedValues;\n  var focusedNode;\n\n  if (!state.selectedValues.length) {\n    var _nodes$;\n\n    if (selectable === 'radio') {\n      var node = depthFirstSearch(nodes, function (node) {\n        return node.value !== undefined;\n      });\n\n      if (node && node.value !== undefined) {\n        selectedValues = [{\n          id: node.id,\n          value: node.value\n        }];\n        focusedNode = node.id;\n      }\n    }\n\n    if (state.focusedNode === null && (nodes === null || nodes === void 0 ? void 0 : nodes.length) && ((_nodes$ = nodes[0]) === null || _nodes$ === void 0 ? void 0 : _nodes$.id) !== undefined) {\n      focusedNode = nodes[0].id;\n    }\n  }\n\n  return _objectSpread(_objectSpread({}, state), {}, {\n    selectedValues: selectedValues !== undefined ? selectedValues : state.selectedValues,\n    focusedNode: focusedNode !== undefined ? focusedNode : state.focusedNode\n  });\n};\n\nvar recursiveInitialize = function recursiveInitialize(nodes, state, selectable) {\n  if (!nodes || nodes.length < 1) {\n    return state;\n  } // Order of statements in this loop is important.\n\n\n  return nodes.reduce(function (acc, node) {\n    var _node$children;\n\n    var parent = getParentId(acc.nodeMap, node.id);\n    var nodeMap = new Map(acc.nodeMap);\n    var flattenedNodeIds = [].concat(_toConsumableArray(acc.flattenedNodeIds), [node.id]);\n    var expandedNodeIds = new Set(acc.expandedNodeIds);\n    var visibleNodeIds;\n    var selectedValues;\n    var focusedNode;\n    nodeMap.set(node.id, {\n      children: new Set((_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.map(function (child) {\n        return child.id;\n      })),\n      id: node.id,\n      parent: parent\n    });\n\n    if (node.expanded) {\n      expandedNodeIds.add(node.id);\n    }\n\n    if (parent !== undefined && expandedNodeIds.has(parent) || parent === undefined) {\n      visibleNodeIds = [].concat(_toConsumableArray(acc.visibleNodeIds), [node.id]);\n    }\n\n    if (node.selected && node.value !== undefined) {\n      if (selectable === 'radio' && !acc.selectedValues.length) {\n        selectedValues = [{\n          id: node.id,\n          value: node.value\n        }];\n        focusedNode = node.id;\n      } else if (selectable === 'multi') {\n        selectedValues = [].concat(_toConsumableArray(acc.selectedValues), [{\n          id: node.id,\n          value: node.value\n        }]);\n\n        if (acc.focusedNode === null) {\n          focusedNode = node.id;\n        }\n      }\n    }\n\n    var newState = _objectSpread(_objectSpread({}, acc), {}, {\n      nodeMap: nodeMap,\n      flattenedNodeIds: flattenedNodeIds,\n      expandedNodeIds: expandedNodeIds,\n      visibleNodeIds: visibleNodeIds !== undefined ? visibleNodeIds : acc.visibleNodeIds,\n      selectedValues: selectedValues !== undefined ? selectedValues : acc.selectedValues,\n      focusedNode: focusedNode !== undefined ? focusedNode : acc.focusedNode\n    });\n\n    if (node.children && node.children.length > 0) {\n      return recursiveInitialize(node.children, newState, selectable);\n    }\n\n    return newState;\n  }, state);\n};\n\nvar getParentId = function getParentId(nodeMap, id) {\n  var iterator = nodeMap.entries();\n\n  var _iterator = _createForOfIteratorHelper(iterator),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          value = _step$value[1];\n\n      if (value.children && value.children.has(id)) {\n        return value.id;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return undefined;\n};\n\nexport var getNextVisibleNode = function getNextVisibleNode(visibleNodeIds, id) {\n  var index = visibleNodeIds.indexOf(id);\n\n  if (index !== -1 && index + 1 < visibleNodeIds.length) {\n    return visibleNodeIds[index + 1];\n  }\n\n  return id;\n};\nexport var getPreviousVisibleNode = function getPreviousVisibleNode(visibleNodeIds, id) {\n  var index = visibleNodeIds.indexOf(id);\n\n  if (index !== -1 && index - 1 >= 0) {\n    return visibleNodeIds[index - 1];\n  }\n\n  return id;\n};\nexport var toggleNode = function toggleNode(state, action) {\n  var node = state.nodeMap.get(action.id);\n  var expandedNodeIds = new Set(state.expandedNodeIds);\n\n  var visibleNodeIds = _toConsumableArray(state.visibleNodeIds);\n\n  if (state.expandedNodeIds.has(action.id)) {\n    expandedNodeIds[\"delete\"](action.id);\n    node === null || node === void 0 ? void 0 : node.children.forEach(function (childId) {\n      var index = visibleNodeIds.indexOf(childId);\n\n      if (index > -1) {\n        visibleNodeIds.splice(index, 1);\n      }\n    });\n  } else {\n    var _node$children2;\n\n    expandedNodeIds.add(action.id);\n    visibleNodeIds.splice.apply(visibleNodeIds, [visibleNodeIds.indexOf(action.id) + 1, 0].concat(_toConsumableArray(Array.from((_node$children2 = node === null || node === void 0 ? void 0 : node.children) !== null && _node$children2 !== void 0 ? _node$children2 : []))));\n  }\n\n  return _objectSpread(_objectSpread({}, state), {}, {\n    expandedNodeIds: expandedNodeIds,\n    visibleNodeIds: visibleNodeIds\n  });\n};\nexport var asyncToggle = function asyncToggle(state, action) {\n  var children = action.children,\n      id = action.id,\n      radio = action.radio;\n  return recursiveToggle(state, radio, id, children);\n};\nexport var recursiveToggle = function recursiveToggle(state, radio, id, children) {\n  if (!children) {\n    return state;\n  }\n\n  var parentNode = state.nodeMap.get(id);\n  var parentIndex = state.flattenedNodeIds.indexOf(id);\n  var childrenIds = children.map(function (_ref) {\n    var id = _ref.id;\n    return id;\n  });\n  var expandedNodeIds = new Set(state.expandedNodeIds);\n\n  var flattenedNodeIds = _toConsumableArray(state.flattenedNodeIds);\n\n  var visibleNodeIds = _toConsumableArray(state.visibleNodeIds);\n\n  var nodeMap = new Map(state.nodeMap);\n\n  var selectedValues = _toConsumableArray(state.selectedValues);\n\n  flattenedNodeIds.splice.apply(flattenedNodeIds, [parentIndex + 1, 0].concat(_toConsumableArray(childrenIds.filter(function (childId) {\n    return !flattenedNodeIds.includes(childId);\n  }))));\n  visibleNodeIds.splice.apply(visibleNodeIds, [parentIndex + 1, 0].concat(_toConsumableArray(childrenIds.filter(function (childId) {\n    return !visibleNodeIds.includes(childId);\n  }))));\n\n  if (parentNode === null || parentNode === void 0 ? void 0 : parentNode.children) {\n    nodeMap.set(id, _objectSpread(_objectSpread({}, parentNode), {}, {\n      children: new Set(childrenIds)\n    }));\n  }\n\n  return children.reduce(function (acc, child) {\n    var _child$children;\n\n    nodeMap.set(child.id, {\n      children: new Set((_child$children = child.children) === null || _child$children === void 0 ? void 0 : _child$children.map(function (_ref2) {\n        var childId = _ref2.id;\n        return childId;\n      })),\n      id: child.id,\n      parent: getParentId(nodeMap, child.id)\n    });\n\n    if (child.expanded) {\n      expandedNodeIds.add(child.id);\n    }\n\n    if (child.selected && child.value !== undefined && (!radio || selectedValues.length === 0)) {\n      selectedValues = [].concat(_toConsumableArray(selectedValues), [{\n        id: child.id,\n        value: child.value\n      }]);\n    }\n\n    var newState = _objectSpread(_objectSpread({}, acc), {}, {\n      nodeMap: nodeMap,\n      flattenedNodeIds: flattenedNodeIds,\n      expandedNodeIds: expandedNodeIds,\n      visibleNodeIds: visibleNodeIds,\n      selectedValues: selectedValues\n    });\n\n    if (child.children && child.children.length > 0) {\n      return recursiveToggle(newState, radio, child.id, child.children);\n    }\n\n    return newState;\n  }, state);\n};","map":null,"metadata":{},"sourceType":"module"}