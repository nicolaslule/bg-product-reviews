{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { usePopper } from 'react-popper';\nimport { useUniqueId } from '../../hooks';\nimport { excludeMarginProps } from '../../mixins';\nimport { Box } from '../Box'; // Margin can't be used with popper elements\n\nexport var Popover = function Popover(_ref) {\n  var anchorElement = _ref.anchorElement,\n      children = _ref.children,\n      isOpen = _ref.isOpen,\n      _ref$role = _ref.role,\n      role = _ref$role === void 0 ? 'dialog' : _ref$role,\n      props = _objectWithoutProperties(_ref, [\"anchorElement\", \"children\", \"isOpen\", \"role\"]);\n\n  var uniquePopoverId = useUniqueId('popover');\n  var rest = excludeMarginProps(props);\n  useEffect(function () {\n    if (!anchorElement) {\n      return;\n    }\n\n    anchorElement.setAttribute('aria-controls', uniquePopoverId);\n    anchorElement.setAttribute('aria-expanded', String(isOpen));\n    anchorElement.setAttribute('aria-haspopup', role);\n  }, [anchorElement, isOpen, role, uniquePopoverId]);\n  return isOpen ? /*#__PURE__*/React.createElement(InternalPopover, _extends({\n    anchorElement: anchorElement\n  }, rest, {\n    id: uniquePopoverId\n  }), children) : null;\n}; // We use an Internal component that mounts/unmounts on isOpen\n// This facilitates running cleanups on some effects.\n\nvar InternalPopover = function InternalPopover(_ref2) {\n  var anchorElement = _ref2.anchorElement,\n      children = _ref2.children,\n      _ref2$closeOnClickOut = _ref2.closeOnClickOutside,\n      closeOnClickOutside = _ref2$closeOnClickOut === void 0 ? true : _ref2$closeOnClickOut,\n      _ref2$closeOnEscKey = _ref2.closeOnEscKey,\n      closeOnEscKey = _ref2$closeOnEscKey === void 0 ? true : _ref2$closeOnEscKey,\n      id = _ref2.id,\n      label = _ref2.label,\n      _ref2$matchAnchorElem = _ref2.matchAnchorElementWidth,\n      matchAnchorElementWidth = _ref2$matchAnchorElem === void 0 ? false : _ref2$matchAnchorElem,\n      _ref2$skidding = _ref2.skidding,\n      skidding = _ref2$skidding === void 0 ? 0 : _ref2$skidding,\n      _ref2$distance = _ref2.distance,\n      distance = _ref2$distance === void 0 ? 4 : _ref2$distance,\n      _ref2$onClose = _ref2.onClose,\n      onClose = _ref2$onClose === void 0 ? function () {\n    return null;\n  } : _ref2$onClose,\n      _ref2$placement = _ref2.placement,\n      placement = _ref2$placement === void 0 ? 'auto' : _ref2$placement,\n      role = _ref2.role,\n      props = _objectWithoutProperties(_ref2, [\"anchorElement\", \"children\", \"closeOnClickOutside\", \"closeOnEscKey\", \"id\", \"label\", \"matchAnchorElementWidth\", \"skidding\", \"distance\", \"onClose\", \"placement\", \"role\"]);\n\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      popperElement = _useState2[0],\n      setPopperElement = _useState2[1];\n\n  var previousFocus = useRef(typeof document !== 'undefined' ? document.activeElement : null);\n  var popperModifiers = useMemo(function () {\n    return [{\n      name: 'offset',\n      options: {\n        offset: [skidding, distance]\n      }\n    }, {\n      name: 'sameWidth',\n      enabled: matchAnchorElementWidth,\n      phase: 'beforeWrite',\n      requires: ['computeStyles'],\n      fn: function fn(_ref3) {\n        var state = _ref3.state;\n        state.styles.popper.width = \"\".concat(state.rects.reference.width, \"px\");\n      },\n      effect: function effect(_ref4) {\n        var state = _ref4.state;\n        var element = state.elements.reference;\n\n        if (element instanceof HTMLElement) {\n          state.elements.popper.style.width = \"\".concat(element.offsetWidth, \"px\");\n        }\n      }\n    }];\n  }, [skidding, distance, matchAnchorElementWidth]);\n\n  var _usePopper = usePopper(anchorElement, popperElement, {\n    modifiers: popperModifiers,\n    placement: placement\n  }),\n      styles = _usePopper.styles,\n      attributes = _usePopper.attributes;\n\n  useEffect(function () {\n    var prevFocus = previousFocus.current;\n    return function () {\n      if (prevFocus && typeof prevFocus.focus === 'function') {\n        prevFocus.focus();\n      }\n    };\n  }, []); // Setup close on click outside\n\n  useEffect(function () {\n    if (typeof document === 'undefined' || !closeOnClickOutside) {\n      return;\n    }\n\n    var clickHandler = function clickHandler(event) {\n      if (!(event.target instanceof Element)) {\n        return;\n      }\n\n      if (popperElement === null || popperElement === void 0 ? void 0 : popperElement.contains(event.target)) {\n        return;\n      }\n\n      onClose();\n    };\n\n    document.addEventListener('click', clickHandler);\n    return function () {\n      document.removeEventListener('click', clickHandler);\n    };\n  }, [closeOnClickOutside, onClose, popperElement]); // Setup close on Esc key\n\n  useEffect(function () {\n    if (typeof document === 'undefined' || !closeOnEscKey) {\n      return;\n    }\n\n    var keydownHandler = function keydownHandler(event) {\n      if (event.key === 'Escape') {\n        onClose();\n      }\n    };\n\n    document.addEventListener('keydown', keydownHandler);\n    return function () {\n      document.removeEventListener('keydown', keydownHandler);\n    };\n  }, [closeOnEscKey, onClose]);\n  return /*#__PURE__*/React.createElement(Box, _extends({\n    \"aria-label\": label,\n    backgroundColor: \"white\",\n    padding: \"medium\",\n    role: role,\n    shadow: \"floating\",\n    tabIndex: -1,\n    zIndex: \"popover\"\n  }, props, attributes.popper, {\n    id: id,\n    ref: setPopperElement,\n    style: styles.popper\n  }), children);\n};","map":null,"metadata":{},"sourceType":"module"}