{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { CheckIcon, ChevronRightIcon, FolderIcon } from '@bigcommerce/big-design-icons';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { typedMemo } from '../../../utils';\nimport { StyledCheckbox } from '../../Checkbox/private';\nimport { StyledRadio } from '../../Radio/styled';\nimport { DelayedSpinner } from '../DelayedSpinner';\nimport { useIsExpanded, useIsSelected, useSelectedChildrenCount } from '../hooks';\nimport { StyledUl } from '../styled';\nimport { StyledArrowWrapper, StyledFlex, StyledFlexItem, StyledGap, StyledLi, StyledSelectableWrapper, StyledText } from './styled';\nvar flexItemProps = {\n  flexShrink: 0,\n  marginLeft: 'xxSmall'\n};\n\nvar InternalTreeNode = function InternalTreeNode(_ref) {\n  var children = _ref.children,\n      disabled = _ref.disabled,\n      dispatch = _ref.dispatch,\n      icon = _ref.icon,\n      iconless = _ref.iconless,\n      id = _ref.id,\n      label = _ref.label,\n      onCollapse = _ref.onCollapse,\n      onExpand = _ref.onExpand,\n      onSelect = _ref.onSelect,\n      selectable = _ref.selectable,\n      state = _ref.state,\n      treeId = _ref.treeId,\n      value = _ref.value;\n  var thisRef = useRef({\n    children: children\n  });\n  var nodeRef = useRef(null);\n  var selectableRef = useRef(null);\n  var treeNodeId = \"\".concat(treeId, \"-treenode-\").concat(id);\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      isLoading = _useState2[0],\n      setIsLoading = _useState2[1];\n\n  var expanded = useIsExpanded(state, id);\n  var selected = useIsSelected(state, value);\n  var selectedChildrenCount = useSelectedChildrenCount(state, children); // Could be multiple elements in which are clicked.\n  // Typing to generic Element type since all other elements extend from it.\n\n  var handleNodeToggle = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(e) {\n      var _selectableRef$curren;\n\n      var callbackValue, _callbackValue;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              dispatch({\n                type: 'FOCUS',\n                id: id\n              }); // Prevents the collapse/expand when clicking on a radio or checkbox\n              // Checks to see if every element inside the selectableRef gets clicked.\n\n              if (!((e === null || e === void 0 ? void 0 : e.target) instanceof Node && ((_selectableRef$curren = selectableRef.current) === null || _selectableRef$curren === void 0 ? void 0 : _selectableRef$curren.contains(e === null || e === void 0 ? void 0 : e.target)) || thisRef.current.children === undefined)) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 3:\n              dispatch({\n                type: 'TOGGLE_NODE',\n                id: id\n              });\n\n              if (!expanded) {\n                _context.next = 12;\n                break;\n              }\n\n              if (!(typeof onCollapse === 'function')) {\n                _context.next = 10;\n                break;\n              }\n\n              _context.next = 8;\n              return onCollapse({\n                children: thisRef.current.children,\n                disabled: disabled,\n                expanded: expanded,\n                id: id,\n                label: label,\n                selected: selected,\n                value: value\n              });\n\n            case 8:\n              callbackValue = _context.sent;\n\n              if (callbackValue) {\n                thisRef.current = callbackValue;\n              }\n\n            case 10:\n              _context.next = 19;\n              break;\n\n            case 12:\n              if (!(typeof onExpand === 'function')) {\n                _context.next = 19;\n                break;\n              }\n\n              setIsLoading(true);\n              _context.next = 16;\n              return onExpand({\n                children: thisRef.current.children,\n                disabled: disabled,\n                expanded: expanded,\n                id: id,\n                label: label,\n                selected: selected,\n                value: value\n              });\n\n            case 16:\n              _callbackValue = _context.sent;\n\n              if (_callbackValue) {\n                thisRef.current = _callbackValue;\n                dispatch({\n                  type: 'ASYNC_TOGGLE',\n                  radio: selectable === 'radio',\n                  id: id,\n                  children: thisRef.current.children\n                });\n              }\n\n              setIsLoading(false);\n\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function handleNodeToggle(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var handleNodeSelected = useCallback(function () {\n    if (selectable === undefined || value === undefined || disabled) {\n      return;\n    }\n\n    var newSelectedValues = _toConsumableArray(state.selectedValues);\n\n    if (selectable === 'multi') {\n      if (newSelectedValues.some(function (selectedValue) {\n        return selectedValue.value === value;\n      })) {\n        newSelectedValues = newSelectedValues.filter(function (selectedValue) {\n          return selectedValue.value !== value;\n        });\n      } else {\n        newSelectedValues = [].concat(_toConsumableArray(newSelectedValues), [{\n          id: id,\n          value: value\n        }]);\n      }\n\n      if (typeof onSelect === 'function') {\n        onSelect(Array.from(newSelectedValues));\n      }\n    }\n\n    if (selectable === 'radio') {\n      newSelectedValues = [{\n        id: id,\n        value: value\n      }];\n\n      if (typeof onSelect === 'function') {\n        onSelect(newSelectedValues[0]);\n      }\n    }\n\n    dispatch({\n      type: 'SELECTED_NODE',\n      values: newSelectedValues\n    });\n  }, [disabled, dispatch, id, onSelect, selectable, state.selectedValues, value]); // Needs to handle the following keyboard events:\n  // https://www.w3.org/TR/wai-aria-practices/#keyboard-interaction-22\n\n  var handleKeyEvent = function handleKeyEvent(e) {\n    var _thisRef$current, _thisRef$current2, _state$nodeMap$get;\n\n    var key = e.key;\n\n    if (e.altKey || e.currentTarget !== e.target) {\n      return;\n    }\n\n    switch (key) {\n      // Stopping propagation if inside a form\n      case ' ':\n        e.preventDefault();\n        e.stopPropagation();\n        handleNodeSelected();\n        break;\n\n      case 'Enter':\n        e.preventDefault();\n        e.stopPropagation();\n\n        if (nodeRef.current === e.currentTarget) {\n          if (thisRef.current.children) {\n            handleNodeToggle();\n          } else if (selectable) {\n            handleNodeSelected();\n          }\n        }\n\n        break;\n\n      case 'ArrowDown':\n        e.preventDefault();\n        dispatch({\n          type: 'FOCUS_DOWN',\n          id: id\n        });\n        break;\n\n      case 'ArrowUp':\n        e.preventDefault();\n        dispatch({\n          type: 'FOCUS_UP',\n          id: id\n        });\n        break;\n\n      case 'ArrowRight':\n        e.preventDefault();\n\n        if ((_thisRef$current = thisRef.current) === null || _thisRef$current === void 0 ? void 0 : _thisRef$current.children) {\n          if (expanded) {\n            dispatch({\n              type: 'FOCUS_DOWN',\n              id: id\n            });\n          } else {\n            handleNodeToggle();\n          }\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        e.preventDefault();\n\n        if ((_thisRef$current2 = thisRef.current) === null || _thisRef$current2 === void 0 ? void 0 : _thisRef$current2.children) {\n          if (expanded) {\n            handleNodeToggle();\n            break;\n          }\n        }\n\n        if (((_state$nodeMap$get = state.nodeMap.get(id)) === null || _state$nodeMap$get === void 0 ? void 0 : _state$nodeMap$get.parent) !== undefined) {\n          dispatch({\n            type: 'FOCUS_UP',\n            id: id\n          });\n        }\n\n        break;\n\n      case 'Home':\n        e.preventDefault();\n        dispatch({\n          type: 'FOCUS_FIRST'\n        });\n        break;\n\n      case 'End':\n        e.preventDefault();\n        dispatch({\n          type: 'FOCUS_LAST'\n        });\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  var additionalProps = useMemo(function () {\n    return selectable ? {\n      'aria-selected': selected\n    } : {};\n  }, [selectable, selected]);\n  var renderedArrow = useMemo(function () {\n    return thisRef.current.children ? /*#__PURE__*/React.createElement(StyledArrowWrapper, {\n      expanded: expanded,\n      flexShrink: 0\n    }, /*#__PURE__*/React.createElement(ChevronRightIcon, {\n      color: \"secondary60\",\n      focusable: false,\n      size: \"xLarge\"\n    })) : /*#__PURE__*/React.createElement(StyledGap, null);\n  }, [expanded]);\n  var renderedChildren = useMemo(function () {\n    var _thisRef$current$chil;\n\n    return thisRef.current.children && expanded && /*#__PURE__*/React.createElement(StyledUl, {\n      role: \"group\"\n    }, isLoading && thisRef.current.children.length < 1 ? /*#__PURE__*/React.createElement(TreeNode, {\n      id: -1,\n      label: \"\",\n      icon: /*#__PURE__*/React.createElement(DelayedSpinner, null),\n      dispatch: dispatch,\n      selectable: selectable,\n      state: state,\n      treeId: treeId\n    }) : (_thisRef$current$chil = thisRef.current.children) === null || _thisRef$current$chil === void 0 ? void 0 : _thisRef$current$chil.map(function (child, index) {\n      return /*#__PURE__*/React.createElement(TreeNode, _extends({}, child, {\n        dispatch: dispatch,\n        iconless: iconless,\n        key: index,\n        onCollapse: onCollapse,\n        onExpand: onExpand,\n        onSelect: onSelect,\n        selectable: selectable,\n        state: state,\n        treeId: treeId\n      }));\n    }));\n  }, [dispatch, expanded, iconless, isLoading, onCollapse, onExpand, onSelect, selectable, state, treeId]);\n  var renderedIcon = useMemo(function () {\n    if (iconless) {\n      return null;\n    }\n\n    return icon ? /*#__PURE__*/React.createElement(StyledFlexItem, flexItemProps, icon) : /*#__PURE__*/React.createElement(StyledFlexItem, flexItemProps, /*#__PURE__*/React.createElement(FolderIcon, {\n      color: disabled ? 'primary20' : 'primary30',\n      size: \"xLarge\"\n    }));\n  }, [disabled, icon, iconless]);\n  var renderedSelectable = useMemo(function () {\n    if (value === undefined && selectable !== undefined) {\n      return null;\n    }\n\n    if (selectable === 'radio') {\n      return /*#__PURE__*/React.createElement(StyledSelectableWrapper, flexItemProps, /*#__PURE__*/React.createElement(StyledRadio, {\n        \"aria-hidden\": true,\n        checked: selected,\n        disabled: disabled,\n        onClick: handleNodeSelected,\n        ref: selectableRef\n      }));\n    }\n\n    if (selectable === 'multi') {\n      return /*#__PURE__*/React.createElement(StyledSelectableWrapper, flexItemProps, /*#__PURE__*/React.createElement(StyledCheckbox, {\n        \"aria-hidden\": true,\n        checked: selected,\n        disabled: disabled,\n        onClick: handleNodeSelected,\n        ref: selectableRef\n      }, selected ? /*#__PURE__*/React.createElement(CheckIcon, null) : null));\n    }\n  }, [disabled, handleNodeSelected, selected, selectable, value]);\n  useEffect(function () {\n    if (state.focusedNode === id) {\n      var _nodeRef$current;\n\n      nodeRef === null || nodeRef === void 0 ? void 0 : (_nodeRef$current = nodeRef.current) === null || _nodeRef$current === void 0 ? void 0 : _nodeRef$current.focus();\n    }\n  }, [state.focusedNode, id]);\n  return /*#__PURE__*/React.createElement(StyledLi, _extends({\n    \"aria-expanded\": expanded,\n    id: treeNodeId,\n    onKeyDown: handleKeyEvent,\n    ref: nodeRef,\n    role: \"treeitem\",\n    tabIndex: state.focusedNode === id ? 0 : -1\n  }, additionalProps), /*#__PURE__*/React.createElement(StyledFlex, {\n    alignItems: \"center\",\n    flexDirection: \"row\",\n    onClick: handleNodeToggle,\n    selected: selected\n  }, renderedArrow, renderedSelectable, renderedIcon, /*#__PURE__*/React.createElement(StyledText, {\n    as: \"span\",\n    ellipsis: true,\n    marginLeft: \"xxSmall\",\n    color: disabled ? 'secondary50' : 'secondary70'\n  }, label, selectedChildrenCount ? /*#__PURE__*/React.createElement(StyledText, {\n    as: \"span\",\n    color: \"primary\"\n  }, ' ', \"(\", selectedChildrenCount, \")\") : null)), renderedChildren);\n};\n\nexport var TreeNode = typedMemo(InternalTreeNode);","map":null,"metadata":{},"sourceType":"module"}